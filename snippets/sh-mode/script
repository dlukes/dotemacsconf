# -*- mode: sh -*-
# name: script
# key: script
# --
#!/usr/bin/env zsh

set -e

root=\${0:h:a}

# copy script stderr to logfile (via named pipe)
exec 2> >(tee -i logfile >&2)

function log {
  >&2 echo "[$(date)] $1"
}

function newline {
  >&2 echo
}

# YN stores the result, but it's not needed since `read -q` returns 1 if the users enters anything
# else than y or Y, so we exit because of `set -e`
read -q "YN?Are you sure (y or n)?"

# run command in background and kill it on exit / termination etc.
sleep 10m &
trap "kill $!" EXIT TERM INT HUP

# kill the shell's process group (= all background and foreground commands) on exit / termination
# etc. (first, convert other signals to EXIT to avoid an infinite loop caused by the kill)
trap exit INT TERM HUP
trap 'kill 0' EXIT

# run multiple commands in background, then wait for them to complete
sleep 2s &
sleep 3s &
sleep 5s &
wait

# mathematical comparisons
foo=4
(( foo == 4 )) && echo true

# regex comparisons
bar="foobarbaz"
[[ $bar =~ "bar" ]] && echo true
! [[ $bar =~ "qux" ]] && echo true
